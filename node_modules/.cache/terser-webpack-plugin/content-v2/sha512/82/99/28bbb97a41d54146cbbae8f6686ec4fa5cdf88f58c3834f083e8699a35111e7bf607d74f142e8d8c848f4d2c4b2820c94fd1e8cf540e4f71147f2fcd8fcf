{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{128:function(t,r,s){\"use strict\";s.r(r);var a=s(0),o=Object(a.a)({},function(){var t=this,r=t.$createElement,s=t._self._c||r;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"hooks简介\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hooks简介\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Hooks简介\")]),t._v(\" \"),s(\"p\",[t._v(\"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。使用函数的情况下也可以编写有状态组件\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"没有破坏性改动\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#没有破坏性改动\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 没有破坏性改动\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[s(\"p\",[s(\"strong\",[t._v(\"完全可选的\")]),s(\"br\"),t._v(\"\\n你无需改写以前的类组件代码，只需在新的组件中去尝试 Hook，Hook 和现有代码可以同时工作，你可以渐进式地使用他们\")])]),t._v(\" \"),s(\"li\",[s(\"p\",[s(\"strong\",[t._v(\"100% 向后兼容的\")]),s(\"br\"),t._v(\"\\nHook 不包含任何破坏性改动\")])]),t._v(\" \"),s(\"li\",[s(\"p\",[s(\"strong\",[t._v(\"现在可用\")]),s(\"br\"),t._v(\"\\nHook 已发布于 v16.8.0\")])])]),t._v(\" \"),s(\"h2\",{attrs:{id:\"动机\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#动机\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 动机\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[s(\"strong\",[t._v(\"在组件之间复用状态逻辑很难\")]),s(\"br\"),t._v(\"\\n现有的方案有render props和高阶组件， 但是这类方案需要重新调整你的代码结构， 另外dom的嵌套层级会增加\")]),t._v(\" \"),s(\"li\",[s(\"strong\",[t._v(\"复杂组件变得难以理解\")]),s(\"br\"),t._v(\"\\n每个生命周期常常包含一些不相关的逻辑，同时去设置事件监听、调用各种接口、初始化等等\")]),t._v(\" \"),s(\"li\",[s(\"strong\",[t._v(\"难以理解的 class\")]),s(\"br\"),t._v(\"\\nclass类增加学习成本，需要手动处理this问题\")])])])},[],!1,null,null,null);r.default=o.exports}}]);","extractedComments":[]}